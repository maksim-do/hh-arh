I. Представим, что у нас есть данные, которые мы очень часто читаем по сравнению с другими(например словарь стран). Как можно это оптимизировать?

  Использовать кэширование данных. В зависмости от ситуации можно кэшировать данные:
  1 на уровне балансировщика(например Nginx cache);
    + вырастает скороть ответа, снижается нагрузка на бэкенд;
    - управление кешированим на Nginx cache - тонкая материя, возможны проблемы с безопасностью,  и встает задача корректно управлять периодом обновления данных

  2 на уровне микросервиса ( например использование Memcached или Redis. ). 
    + быстродействие( данные хранятся в оперативной памяти), масштабируемость( увеличение обьема ОП или кластеризация)
    - более низкая надежность по сравнению с традиционными субд, т.к основная часть данных хранится в энергозависимой памяти, существенные затраты при масштабировании;


II. Что можно сделать, если таблица вакансий стала слишком большой? Какие есть решения на уровне текущей базы данных? Можно ли ее чем то заменить?

  В принципе все таблицы растут и если это не приводет в обозримом будущем к проблемам то и пусть себе растет.
  Однако если этот становится проблемой, то первое, что нужно сделать это проанализировавать и возможно изменить алгоритм заполнения и структуру данных, возможно данные которые там хранятся избыточны.
  Если со структурой и заполнением все ОК. То варианты решения:
  1 партиционирование этой таблицы на несколько таблиц;
    + Гибкое управление данными, за счет действий над отдельными секциями (сжатие, перенос на отдельный диск, перенос данных на другие инстансы, бэкапирование и др.)
    Ускорение операций обслуживания (перестроение индексов и обновление статистик по секциям).
    Повышение производительности запросов в  некоторых ситуациях (за счет исключений обращений к секциям, которые не соответствую фильтрам запроса и возможном разнесении секций на отдельные диски)
    - Сложность администрирования и поддержки,  требуются дополнительные компетенции и секционирование должно учитываться при модификации базы. Так же , секкционирование может вызвать проблемы производительности в некоторых запросах. Например, из-за дополнительной операции соединения наборов данных из разных секций. Это стоит учитывать при планировании инфраструктуры и написания SQL-запросов.
  2 Рассмотреть возможность миграции на более производительные сервера или поднять кластер.
    +   снимается проблема с хранением и обработкой проблемной таблицы
    - требует существенных затрат, при быстром росте таблицы решение дает временный эффект
  3 Переехать на какую-нибудь другую СУБД, которая лучше справляется с обработкой больших таблиц;
    +   снимается проблема с хранением и обработкой проблемной таблицы
    -   возможные проблемы с миграцией, вполне вероятно это будет очень хлопотно и затратно.

  III. Какие вы видите узкие места, возможно неправильно выбранные технологии в текущей схеме(можно рассмотреть как “нашу” схему, так и схему настоящего hh.ru)

  К сожалению реального опыта построения и внедрения приложения с сервис-ориентированной архитектурой у меня нет. Но глядя на схему нашего проекта есть пара мыслей.
  1 Схема активно разрослась, но вполне возможно что нам для озвученных задач вполне бы подошла монолитная модель приложения

  + не нужно тратить много времени на первоначальное деление системы на компоненты и организацию взаимодействия между ними.
  - сложно разрабатывать монолитную структуру, которую впоследствии можно будет безболезненно преобразовать в сервис-ориентированную.

  2 Объеденить все app  и внутрений балансировщик в единый модуль

  + исключение дублирования функций и упростить администрирование
  - все минусы монолитных структур

  3 заменить  все app, внутрений балансировщик, worker и queue слоем микросервисов которые общались бы с СУБД через балансировщик.
  + понятно за что отвечает конкретная часть системы
    cвободный выбор языка
    cвободный выбор хранилища
    эффективное использование ресурсов
  - тяжелые вызовы (сетевой оверхед, сериализация)
    сложное управление и развертывание
